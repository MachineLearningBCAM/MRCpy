
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples\further_examples\plot_upperLower.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_further_examples_plot_upperLower.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_further_examples_plot_upperLower.py:


.. _pruebas:

Example: Use of Upper and Lower bound as error estimation
==================================================================

This example is an extension to `ex2` where we will prove how the upper and
lower bound of the loss are an unbiased estimator of the error. The models are
trained with different number of cases ranging from 10% to 80% of the data and
then are tested with 20% of the samples. The graphs show how in most of the
cases the error is between those bounds which proves the potential of this
feature of the MRCs. The results are for a
:mod:`MRC(phi = 'fourier', loss = '0-1', s = 1)`


.. note::    Note that there is an additional dataset related to COVID-19
             patients that is available upon requesting to HM Hospitales
             `here
             <www.hmhospitales.com/coronavirus/covid-data-save-lives/>`_.
             More information about this dataset can be found in the
             `COVID example<ex_covid>`

.. GENERATED FROM PYTHON SOURCE LINES 24-180

.. code-block:: default


    # Import needed modules
    import time

    import matplotlib.pyplot as plt
    from imblearn.over_sampling import SMOTE
    import numpy as np
    import pandas as pd
    import seaborn as sns
    from sklearn import preprocessing
    from sklearn.model_selection import RepeatedStratifiedKFold

    from MRCpy import MRC
    from MRCpy.datasets import *


    sns.set_style("whitegrid")
    sns.set_context("paper")


    def load_covid(norm=False, array=True):
        data_consensus = pd.read_csv("data/data_consensus.csv", sep=";")

        variable_dict = {
            "CD0000AGE": "Age",
            "CORE": "PATIENT_ID",
            "CT000000U": "Urea",
            "CT00000BT": "Bilirubin",
            "CT00000NA": "Sodium",
            "CT00000TP": "Proth_time",
            "CT0000COM": "Com",
            "CT0000LDH": "LDH",
            "CT0000NEU": "Neutrophils",
            "CT0000PCR": "Pro_C_Rea",
            "CT0000VCM": "Med_corp_vol",
            "CT000APTT": "Ceph_time",
            "CT000CHCM": "Mean_corp_Hgb",
            "CT000EOSP": "Eosinophils%",
            "CT000LEUC": "Leukocytes",
            "CT000LINP": "Lymphocytes%",
            "CT000NEUP": "Neutrophils%",
            "CT000PLAQ": "Platelet_count",
            "CTHSDXXRATE": "Rate",
            "CTHSDXXSAT": "Sat",
            "ED0DISWHY": "Status",
            "F_INGRESO/ADMISSION_D_ING/INPAT": "Fecha_admision",
            "SEXO/SEX": "Sexo",
        }
        data_consensus = data_consensus.rename(columns=variable_dict)
        if norm:
            x_consensus = data_consensus[
                data_consensus.columns.difference(["Status", "PATIENT_ID"])
            ][:]
            std_scale = preprocessing.StandardScaler().fit(x_consensus)
            x_consensus_std = std_scale.transform(x_consensus)
            dataframex_consensus = pd.DataFrame(
                x_consensus_std, columns=x_consensus.columns
            )
            data_consensus.reset_index(drop=True, inplace=True)
            data_consensus = pd.concat(
                [dataframex_consensus, data_consensus[["Status"]]], axis=1
            )
        data_consensus = data_consensus[data_consensus.columns.difference(
            ["PATIENT_ID"])]
        X = data_consensus[data_consensus.columns.difference(
            ["Status", "PATIENT_ID"])]
        y = data_consensus["Status"]
        if array:
            X = X.to_numpy()
            y = y.to_numpy()
        return X, y


    def getUpperLowerdf(train_size, X, y, cv, paramsMRC, smote=True):
        """
        Parameters
        ----------
        train_size : array
            Array of different training sizes to train the model.
        cv : CrossValidator
            Cross validator.
        paramsMRC : TYPE
            Parameters for the MRCs.
        smote : Bool, optional
            Class imbalance corrector, set to false to disable. The default is
            True.
        Returns
        -------
        table : dataFrame
            Dataframe with the results of the training for each training size.

        """
        if smote:
            smotefit = SMOTE(sampling_strategy="auto")
            X, y = smotefit.fit_resample(X, y)
        table = pd.DataFrame()
        for train_set in train_size:
            for j, (train_index, test_index) in enumerate(cv.split(X, y)):
                X_train, X_test = X[train_index], X[test_index]
                y_train, y_test = y[train_index], y[test_index]

                random_indices = np.random.choice(
                    X_train.shape[0], size=int(X.shape[0] * train_set),
                    replace=False,
                )
                X_train = X_train[random_indices, :]
                y_train = y_train[random_indices]
                std_scale = preprocessing.StandardScaler().fit(X_train, y_train)
                X_train = std_scale.transform(X_train)
                X_test = std_scale.transform(X_test)
                start_time = time.time()
                MRC_model = MRC(phi="fourier", s=1, **
                                paramsMRC).fit(X_train, y_train)
                train_time = time.time() - start_time
                auxtable = pd.DataFrame(
                    columns=["Error", "Upper", "Lower", "iteration", "train_size",
                             "Time", ],
                    index=range(0, 1),
                )
                auxtable["train_size"] = train_set
                auxtable["iteration"] = j
                auxtable["Error"] = 1 - MRC_model.score(X_test, y_test)
                auxtable["Time"] = train_time
                auxtable["Upper"] = MRC_model.get_upper_bound()
                auxtable["Lower"] = MRC_model.get_lower_bound()

                table = table.append(auxtable, ignore_index=True)
        return table


    # Data sets
    loaders = [
        load_mammographic,
        load_haberman,
        load_indian_liver,
        load_diabetes,
        load_credit,
        load_covid,
    ]

    dataName = [
        "mammographic",
        "haberman",
        "indian_liver",
        "diabetes",
        "credit",
        "COVID",
    ]
    paramsMRC = {
        "deterministic": False,
        "fit_intercept": False,
        "use_cvx": True,
        "loss": "0-1",
    }
    train = np.arange(0.1, 0.81, 0.1)








.. GENERATED FROM PYTHON SOURCE LINES 181-185

Cross test validation
~~~~~~~~~~~~~~~~~~~~
5 fold repeated Stratified Cross validation is performed where each of the
fold is trained with 80% of the data and then tested with the remaining 20%

.. GENERATED FROM PYTHON SOURCE LINES 185-191

.. code-block:: default


    n_splits = 5
    n_repeats = 10
    cv = RepeatedStratifiedKFold(n_splits=n_splits, n_repeats=n_repeats,
                                 random_state=1)








.. GENERATED FROM PYTHON SOURCE LINES 192-200

Results
====================
We will present the results for the 6 datasets. For more information
about the dataset refer to the
`MRCpy documentation <https://machinelearningbcam.github.io/MRCpy>`_ of the
loaders. In the results we can see how the upper and lower bounds get closer
when the training size is increased. Furthermore, the standard deviation of
both bounds is reduced significantly.

.. GENERATED FROM PYTHON SOURCE LINES 202-204

Mammographic
~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 204-219

.. code-block:: default

    X, y = load_mammographic()
    table = getUpperLowerdf(train, X, y, cv, paramsMRC)
    # dataframes.append(table)
    # plotUpperLower(table)
    means = table[table.columns.difference(["iteration"])].groupby(
        "train_size").mean()
    std = table[table.columns.difference(["iteration"])].groupby(
        "train_size").std()
    for column in means.columns:
        means[column] = (
            means[column].round(3).astype(str) + " ± " + std[column].round(
                3).astype(str)
        )
    means[["Error", "Upper", "Lower", "Time"]]



.. rst-class:: sphx-glr-script-out

.. code-block:: pytb

    Traceback (most recent call last):
      File "C:\Users\X001103\Desktop\BCAM_work\COVID PROGNOSIS\MRCpy\examples\further_examples\plot_upperLower.py", line 205, in <module>
        table = getUpperLowerdf(train, X, y, cv, paramsMRC)
      File "C:\Users\X001103\Desktop\BCAM_work\COVID PROGNOSIS\MRCpy\examples\further_examples\plot_upperLower.py", line 148, in getUpperLowerdf
        auxtable["Lower"] = MRC_model.get_lower_bound()
      File "C:\Users\X001103\anaconda3\lib\site-packages\mrcpy-0.1.1-py3.9.egg\MRCpy\mrc.py", line 497, in get_lower_bound
        self.try_solvers(objective, None, low_mu)
      File "C:\Users\X001103\anaconda3\lib\site-packages\mrcpy-0.1.1-py3.9.egg\MRCpy\base_mrc.py", line 393, in try_solvers
        prob.solve(solver=self.solver, verbose=False)
      File "C:\Users\X001103\anaconda3\lib\site-packages\cvxpy\problems\problem.py", line 472, in solve
        return solve_func(self, *args, **kwargs)
      File "C:\Users\X001103\anaconda3\lib\site-packages\cvxpy\problems\problem.py", line 978, in _solve
        self.unpack_results(solution, solving_chain, inverse_data)
      File "C:\Users\X001103\anaconda3\lib\site-packages\cvxpy\problems\problem.py", line 1300, in unpack_results
        raise error.SolverError(
    cvxpy.error.SolverError: Solver 'MOSEK' failed. Try another solver, or solve with verbose=True for more information.




.. GENERATED FROM PYTHON SOURCE LINES 220-243

.. code-block:: default

    fig, ax = plt.subplots()
    sns.lineplot(data=table, x="train_size", y="Error", label="Test Error", ax=ax)
    sns.lineplot(
        data=table,
        x="train_size",
        y="Upper",
        color="red",
        label="Upper bound",
        linestyle="dotted",
        ax=ax,
    )
    sns.lineplot(
        data=table,
        x="train_size",
        y="Lower",
        color="green",
        label="Lower bound",
        linestyle="dotted",
        ax=ax,
    )
    plt.suptitle("Mammographic")
    plt.show()


.. GENERATED FROM PYTHON SOURCE LINES 244-246

Haberman
~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 246-260

.. code-block:: default


    X, y = load_haberman()
    table = getUpperLowerdf(train, X, y, cv, paramsMRC)
    means = table[table.columns.difference(
        ["iteration"])].groupby("train_size").mean()
    std = table[table.columns.difference(
        ["iteration"])].groupby("train_size").std()
    for column in means.columns:
        means[column] = (
            means[column].round(3).astype(
                str) + " ± " + std[column].round(3).astype(str)
        )
    means[["Error", "Upper", "Lower", "Time"]]


.. GENERATED FROM PYTHON SOURCE LINES 261-284

.. code-block:: default

    fig, ax = plt.subplots()
    sns.lineplot(data=table, x="train_size", y="Error", label="Test Error", ax=ax)
    sns.lineplot(
        data=table,
        x="train_size",
        y="Upper",
        color="red",
        label="Upper bound",
        linestyle="dotted",
        ax=ax,
    )
    sns.lineplot(
        data=table,
        x="train_size",
        y="Lower",
        color="green",
        label="Lower bound",
        linestyle="dotted",
        ax=ax,
    )
    plt.suptitle("Haberman")
    plt.show()


.. GENERATED FROM PYTHON SOURCE LINES 285-287

Indian liver
~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 287-300

.. code-block:: default

    X, y = load_indian_liver()

    table = getUpperLowerdf(train, X, y, cv, paramsMRC)
    means = table[table.columns.difference(
        ["iteration"])].groupby("train_size").mean()
    std = table[table.columns.difference(
        ["iteration"])].groupby("train_size").std()
    for column in means.columns:
        means[column] = (
            means[column].round(3).astype(str) + " ± " +
            std[column].round(3).astype(str)
        )
    means[["Error", "Upper", "Lower", "Time"]]

.. GENERATED FROM PYTHON SOURCE LINES 301-323

.. code-block:: default

    fig, ax = plt.subplots()
    sns.lineplot(data=table, x="train_size", y="Error", label="Test Error", ax=ax)
    sns.lineplot(
        data=table,
        x="train_size",
        y="Upper",
        color="red",
        label="Upper bound",
        linestyle="dotted",
        ax=ax,
    )
    sns.lineplot(
        data=table,
        x="train_size",
        y="Lower",
        color="green",
        label="Lower bound",
        linestyle="dotted",
        ax=ax,
    )
    plt.suptitle("Indian Liver")
    plt.show()

.. GENERATED FROM PYTHON SOURCE LINES 324-326

diabetes
~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 326-340

.. code-block:: default

    X, y = load_diabetes()

    table = getUpperLowerdf(train, X, y, cv, paramsMRC)
    means = table[table.columns.difference(
        ["iteration"])].groupby("train_size").mean()
    std = table[table.columns.difference(
        ["iteration"])].groupby("train_size").std()
    for column in means.columns:
        means[column] = (
            means[column].round(3).astype(str) + " ± " +
            std[column].round(3).astype(str)
        )
    means[["Error", "Upper", "Lower", "Time"]]


.. GENERATED FROM PYTHON SOURCE LINES 341-363

.. code-block:: default

    fig, ax = plt.subplots()
    sns.lineplot(data=table, x="train_size", y="Error", label="Test Error", ax=ax)
    sns.lineplot(
        data=table,
        x="train_size",
        y="Upper",
        color="red",
        label="Upper bound",
        linestyle="dotted",
        ax=ax,
    )
    sns.lineplot(
        data=table,
        x="train_size",
        y="Lower",
        color="green",
        label="Lower bound",
        linestyle="dotted",
        ax=ax,
    )
    plt.suptitle("Diabetes")
    plt.show()

.. GENERATED FROM PYTHON SOURCE LINES 364-366

credit
~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 366-380

.. code-block:: default

    X, y = load_credit()

    table = getUpperLowerdf(train, X, y, cv, paramsMRC)
    means = table[table.columns.difference(
        ["iteration"])].groupby("train_size").mean()
    std = table[table.columns.difference(
        ["iteration"])].groupby("train_size").std()
    for column in means.columns:
        means[column] = (
            means[column].round(3).astype(str) + " ± " +
            std[column].round(3).astype(str)
        )
    means[["Error", "Upper", "Lower", "Time"]]


.. GENERATED FROM PYTHON SOURCE LINES 381-403

.. code-block:: default

    fig, ax = plt.subplots()
    sns.lineplot(data=table, x="train_size", y="Error", label="Test Error", ax=ax)
    sns.lineplot(
        data=table,
        x="train_size",
        y="Upper",
        color="red",
        label="Upper bound",
        linestyle="dotted",
        ax=ax,
    )
    sns.lineplot(
        data=table,
        x="train_size",
        y="Lower",
        color="green",
        label="Lower bound",
        linestyle="dotted",
        ax=ax,
    )
    plt.suptitle("Credit")
    plt.show()

.. GENERATED FROM PYTHON SOURCE LINES 404-406

COVID
~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 406-420

.. code-block:: default

    X, y = load_covid()

    table = getUpperLowerdf(train, X, y, cv, paramsMRC)
    means = table[table.columns.difference(
        ["iteration"])].groupby("train_size").mean()
    std = table[table.columns.difference(
        ["iteration"])].groupby("train_size").std()
    for column in means.columns:
        means[column] = (
            means[column].round(3).astype(str) + " ± " +
            std[column].round(3).astype(str)
        )
    means[["Error", "Upper", "Lower", "Time"]]


.. GENERATED FROM PYTHON SOURCE LINES 421-443

.. code-block:: default

    fig, ax = plt.subplots()
    sns.lineplot(data=table, x="train_size", y="Error", label="Test Error", ax=ax)
    sns.lineplot(
        data=table,
        x="train_size",
        y="Upper",
        color="red",
        label="Upper bound",
        linestyle="dotted",
        ax=ax,
    )
    sns.lineplot(
        data=table,
        x="train_size",
        y="Lower",
        color="green",
        label="Lower bound",
        linestyle="dotted",
        ax=ax,
    )
    plt.suptitle("COVID")
    plt.show()


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  10.798 seconds)


.. _sphx_glr_download_auto_examples_further_examples_plot_upperLower.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_upperLower.py <plot_upperLower.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_upperLower.ipynb <plot_upperLower.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
